### 分页

##### a. 分页，看第n页，每页显示n条数据；

~~~python
from rest_framework.pagination import PageNumberPagination

class MyPageNumberPagination(PageNumberPagination):

    page_size = 2  # 每页默认数据条数
    page_size_query_param = 'size'  # 每页条数 关键字
    max_page_size = 5  # 每页最大条数

    page_query_param = 'page'  # 查询第几页 关键字

class Pager1View(APIView):

    def get(self,request,*args,**kwargs):

        # 获取所有数据
        roles = models.Role.objects.all()

        # 创建分页对象
        pg = MyPageNumberPagination()
        # pg = PageNumberPagination()

        # 在数据库中获取分页的数据
        pager_roles = pg.paginate_queryset(queryset=roles,request=request,view=self)

        # 对数据进行序列化
        ser = PagerSerialiser(instance=pager_roles, many=True)

        return Response(ser.data)
        # return pg.get_paginated_response(ser.data)  # 总页数，上一页，下一页
~~~





##### b. 分页，在n个位置，向后查看n条数据；

~~~python
from api.utils.serializsers.pager import PagerSerialiser
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination,LimitOffsetPagination


class MyLimitOffsetPagination(LimitOffsetPagination):
    default_limit = 2  # 默认每页的数据量  
    limit_query_param = 'limit'  # 往后取多少条
    offset_query_param = 'offset'  # 位置  从0开始
    max_limit = 5  # 每页最大条数
     
	def get_offset(self, request):
        """让 offset_query_param 字段设置的值失效， 一直从位置0开始"""
        return 0 

    def get_paginated_response(self, data):
        # 定制数据的返回格式
        return Response(data)
    

class Pager1View(APIView):

    def get(self,request,*args,**kwargs):

        # 获取所有数据
        roles = models.Role.objects.all()

        # 创建分页对象
        pg = MyLimitOffsetPagination()
        # pg = LimitOffsetPagination()

        # 在数据库中获取分页的数据
        pager_roles = pg.paginate_queryset(queryset=roles,request=request,view=self)

        # 对数据进行序列化
        ser = PagerSerialiser(instance=pager_roles, many=True)

        return Response(ser.data)
        # return pg.get_paginated_response(ser.data)
~~~





##### c. 加密分页，上一页和下一页。

~~~tiki wiki
记录下当前页面的 最大、最小 id，查询上一页、下一页的数据时 直接根据 最小、最大id 的偏移量 进行查询

url上对页码进行加密
~~~

~~~python
from api.utils.serializsers.pager import PagerSerialiser
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination,LimitOffsetPagination,CursorPagination

class MyCursorPagination(CursorPagination):
    cursor_query_param = 'cursor'  # 游标 关键字
    page_size = 2  # 默认每页条数
    ordering = 'id'  # 排序规则
    page_size_query_param = None  # 每页显示多少个  关键字
    max_page_size = None  # 每页最大的条数

class Pager1View(APIView):

    def get(self,request,*args,**kwargs):

        # 获取所有数据
        roles = models.Role.objects.all()

        # 创建分页对象
        # pg = CursorPagination()
        pg = MyCursorPagination()

        # 在数据库中获取分页的数据
        pager_roles = pg.paginate_queryset(queryset=roles,request=request,view=self)

        # 对数据进行序列化
        ser = PagerSerialiser(instance=pager_roles, many=True)

        # return Response(ser.data)
        return pg.get_paginated_response(ser.data)
~~~



##### 面试题

~~~
1. 数据量大的话，如何做分页？  
		
		加密分页、限制只能前200页
	
   数据库性能相关？  
   
   		索引、分页
~~~



### 扩展: 分页的优化

~~~
记录最大值和最小值，防止切片时全部数据扫描的问题。


缺点: 只能查找 上一页、下一页的数据

解释: 假如每页10条数据，
- 如果不记录最大值和最小值; 当查找第10页的数据时，需要遍历前100条数据，取出最后10条；当数据量比较大，取的页数比较大时，效率非常低。
- 如果记录最大值和最小值;当查找第10页数据时，只需要跳到第91条数据，然后往后取10条;
~~~









