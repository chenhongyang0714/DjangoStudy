### 序列化 

~~~python
# 作用
1. 对QuesySet数据进行序列化(一个或多个)
2. 对请求数据进行校验
~~~

#### 作用一：对QuesySet数据进行序列化

##### 继承 serializers.Serializer

###### 一张表的一个字段序列化

~~~python
from rest_framework import serializers

# Role模型
class Role(models.Model):
    title = models.CharField(max_length=32)

# 定义序列化类
class RolesSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField()


class RolesView(APIView):
    def get(self, request, *args, **kwargs):
        # 方式一：
        # roles = models.Role.objects.all().values('id','title')
        # roles = list(roles)
        # ret = json.dumps(roles,ensure_ascii=False)

        # 方式二：对于 [obj,obj,obj, ...]
        # roles = models.Role.objects.all()  # Query_set 对象
        # # many=True 表示 roles中有多条数据
        # ser = RolesSerializer(instance=roles, many=True)
        # ret = json.dumps(ser.data, ensure_ascii=False)

        # 对于 [obj]
        role = models.Role.objects.all().first()
        # many=False 表示 roles中有一条数据
        # partial=True 允许修改一部分数据 用于patch请求
        ser = RolesSerializer(instance=role, many=False)  
        
        # print(f"ser.data: {ser.data}")  # {'id': 1, 'title': '医生'}
        # ser.data 已经是转换完成的结果

        ret = json.dumps(ser.data, ensure_ascii=False)
        return HttpResponse(ret)
~~~

###### 一对多、多对多的序列化

~~~python
# 模型
class UserInfo(models.Model):
    user_type_choices = (
        (1, '普通用户'),
        (2, 'VIP'),
        (3, 'SVIP'),
    )
    user_type = models.IntegerField(choices=user_type_choices)

    username = models.CharField(max_length=32, unique=True)
    password = models.CharField(max_length=64)

    group = models.ForeignKey("UserGroup", on_delete=models.CASCADE)
    roles = models.ManyToManyField("Role")

class UserGroup(models.Model):
    title = models.CharField(max_length=32)
class Role(models.Model):
	title = models.CharField(max_length=32)

# 序列化类
from rest_framework import serializers
class UserInfoSerializer(serializers.Serializer):
    xxxxx = serializers.CharField(source="user_type") # row.user_type
    oooo = serializers.CharField(source="get_user_type_display") # row.get_user_type_display()
    username = serializers.CharField()
    password = serializers.CharField()
    gp = serializers.CharField(source="group.title")  # ForeignKey
    # rls = serializers.CharField(source="roles.all")  # ManyToManyField  无法实现特别细力度
    rls = serializers.SerializerMethodField() # 自定义显示
	
    # 自定义方法
    def get_rls(self,obj):
		"""
		返回什么，展示什么
		"""
        role_obj_list = obj.roles.all()

        ret = []
        for item in role_obj_list:
            ret.append({'id':item.id,'title':item.title})
        return ret
~~~



##### 继承 serializers.ModelSerializer

~~~python
from rest_framework import serializers

# 自定义类
class MyField(serializers.CharField):

    def to_representation(self, value):
        print(value)
        return value
    
class UserInfoSerializer(serializers.ModelSerializer):
    oooo = serializers.CharField(source="get_user_type_display")  # row.user_type
    rls = serializers.SerializerMethodField()  # 自定义显示
	x1 = MyField(source='username')
    
    class Meta:
        model = models.UserInfo
        # fields = "__all__"
        fields = ['id','username','password','group','oooo','rls','x1']

    def get_rls(self, row):
        role_obj_list = row.roles.all()

        ret = []
        for item in role_obj_list:
            ret.append({'id':item.id,'title':item.title})
        return ret
~~~

###### 自动序列化连表 (建议 depth )

~~~python
class UserInfoSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.UserInfo
        # fields = "__all__"
        fields = ['id','username','password','group','roles']
        depth = 1 # 官方建议0 ~ 10
~~~

###### 生成链接

~~~python
# 生成链接

class UserInfoSerializer(serializers.ModelSerializer):	
    group = serializers.HyperlinkedIdentityField(view_name='gp',lookup_field='group_id',lookup_url_kwarg='xxx')
    
    class Meta:
        model = models.UserInfo
        # fields = "__all__"
        fields = ['id','username','password','group','roles']
        depth = 0 # 0 ~ 10

class UserInfoView(APIView):
    def get(self,request,*args,**kwargs):

        users = models.UserInfo.objects.all()

        ser = UserInfoSerializer(instance=users,many=True,context={'request': request})
        ret = json.dumps(ser.data, ensure_ascii=False)
        return HttpResponse(ret)
    
    
# 根据链接获取数据
url(r'^(?P<version>[v1|v2]+)/group/(?P<xxx>\d+)$', views.GroupView.as_view(), name='gp'),

class GroupSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.UserGroup
        fields = "__all__"


class GroupView(APIView):
    def get(self, request, *args, **kwargs):
        pk = kwargs.get('xxx')
        obj = models.UserGroup.objects.filter(pk=pk).first()

        ser = GroupSerializer(instance=obj, many=False)
        ret = json.dumps(ser.data, ensure_ascii=False)
        return HttpResponse(ret)
~~~



#### 作用二：对请求数据进行校验

~~~
注意: 
validated_data 只能在 is_valid()  之后使用

注意与initial_data的区别
~~~



~~~python
# 自定义 类校验

# 方式一   validators自定义类

class XXValidator(object):
    def __init__(self, base):
        # base为 老男人
        self.base = base

	def __call__(self, value):
       	"""value为前端传的数据"""
        if not value.startswith(self.base):
            message = '标题必须以 %s 为开头。' % self.base
            raise serializers.ValidationError(message)

	def set_context(self, serializer_field):
        # 执行验证之前调用,serializer_fields是当前字段对象
        pass

class UserGroupSerializer(serializers.Serializer):
	title = serializers.CharField(error_messages={'required':'标题不能为空'},validators=[XXValidator('老男人'),])


class UserGroupView(APIView):

    def post(self,request,*args,**kwargs):

        ser = UserGroupSerializer(data=request.data)
        if ser.is_valid():
            print(ser.validated_data['title'])
            
            # 将校验后的数据存到数据库
            # 方式1
            ***.objects.create(title=ser.validated_data)
            # 方式2
            ser.save()  
           	ser.save(...=...)  # 存入数据库, 需要添加额外字段时  (user_id=1)
            
        else: 
			print(ser.errors)
        return HttpResponse('提交数据')
 

# 方式二   validators自定义函数
def phone_validator(value):
    """
    对手机号码进行校验
    """
    if not re.match(r'^(1[3|4|5|6|7|8|9])\d{9}$', value):
        raise ValidationError('手机号码格式错误')

class PhoneSerializer(serializers.Serializer):
    """
    对手机号码进行校验
    """
    phone = serializers.CharField(label='手机号码', validators=[phone_validator, ])


# 方式三   钩子函数
    
    
# 钩子函数校验  (情景一)
class UserGroupSerializer(serializers.Serializer):
    title = serializers.CharField(error_messages={'required': '标题不能为空'}, validators=[XXValidator('老男人'), ])

    # 通过钩子函数 自定义验证规则
    # 注意函数名  _title
    def validate_title(self, value):
        if not value.startswith('老男人'):
            from rest_framework import exceptions
            raise exceptions.ValidationError('标题必须以老男人为开头')
        return value

    
# 钩子函数校验  (情景二)
class UserGroupSerializer(serializers.Serializer):
    # 校验顺序为  先 phone 后 code
    phone = ...
    code = ...

    # 注意函数名  _code
    def validate_code(self, value):
        
        phone = self.initial_data.get('phone')
        ....
        
        return value
~~~



























